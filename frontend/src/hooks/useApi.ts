import { useState, useCallback } from 'react';\nimport { AxiosError } from 'axios';\nimport toast from 'react-hot-toast';\n\ninterface ApiState<T> {\n  data: T | null;\n  loading: boolean;\n  error: string | null;\n}\n\ninterface UseApiOptions {\n  showSuccessToast?: boolean;\n  showErrorToast?: boolean;\n  successMessage?: string;\n  errorMessage?: string;\n}\n\ninterface UseApiReturn<T, P extends any[] = []> {\n  data: T | null;\n  loading: boolean;\n  error: string | null;\n  execute: (...params: P) => Promise<T | null>;\n  reset: () => void;\n}\n\n/**\n * Custom hook for handling API calls with loading, error states, and toast notifications\n */\nexport function useApi<T, P extends any[] = []>(\n  apiFunction: (...params: P) => Promise<T>,\n  options: UseApiOptions = {}\n): UseApiReturn<T, P> {\n  const {\n    showSuccessToast = false,\n    showErrorToast = true,\n    successMessage,\n    errorMessage,\n  } = options;\n\n  const [state, setState] = useState<ApiState<T>>({\n    data: null,\n    loading: false,\n    error: null,\n  });\n\n  const execute = useCallback(\n    async (...params: P): Promise<T | null> => {\n      setState(prev => ({ ...prev, loading: true, error: null }));\n\n      try {\n        const result = await apiFunction(...params);\n        setState({ data: result, loading: false, error: null });\n        \n        if (showSuccessToast) {\n          toast.success(successMessage || 'Operation completed successfully');\n        }\n        \n        return result;\n      } catch (error) {\n        const errorMsg = getErrorMessage(error);\n        setState({ data: null, loading: false, error: errorMsg });\n        \n        if (showErrorToast) {\n          toast.error(errorMessage || errorMsg || 'An error occurred');\n        }\n        \n        return null;\n      }\n    },\n    [apiFunction, showSuccessToast, showErrorToast, successMessage, errorMessage]\n  );\n\n  const reset = useCallback(() => {\n    setState({ data: null, loading: false, error: null });\n  }, []);\n\n  return {\n    data: state.data,\n    loading: state.loading,\n    error: state.error,\n    execute,\n    reset,\n  };\n}\n\n/**\n * Extract error message from various error types\n */\nfunction getErrorMessage(error: unknown): string {\n  if (error instanceof AxiosError) {\n    return error.response?.data?.message || error.message || 'Network error occurred';\n  }\n  \n  if (error instanceof Error) {\n    return error.message;\n  }\n  \n  if (typeof error === 'string') {\n    return error;\n  }\n  \n  return 'An unknown error occurred';\n}\n\n/**\n * Hook for API calls that don't need state management (fire-and-forget)\n */\nexport function useApiAction<P extends any[] = []>(\n  apiFunction: (...params: P) => Promise<any>,\n  options: UseApiOptions = {}\n) {\n  const [loading, setLoading] = useState(false);\n\n  const execute = useCallback(\n    async (...params: P): Promise<boolean> => {\n      setLoading(true);\n\n      try {\n        await apiFunction(...params);\n        \n        if (options.showSuccessToast) {\n          toast.success(options.successMessage || 'Operation completed successfully');\n        }\n        \n        setLoading(false);\n        return true;\n      } catch (error) {\n        const errorMsg = getErrorMessage(error);\n        \n        if (options.showErrorToast !== false) {\n          toast.error(options.errorMessage || errorMsg || 'An error occurred');\n        }\n        \n        setLoading(false);\n        return false;\n      }\n    },\n    [apiFunction, options.showSuccessToast, options.showErrorToast, options.successMessage, options.errorMessage]\n  );\n\n  return { execute, loading };\n}\n\nexport default useApi;